Index: set.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"set.h\"\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n\r\nstatic const size_t MIN_SIZE = 5;\r\n\r\n\r\ntypedef struct SET {\r\n    size_t itemSize;\r\n    size_t setSize;\r\n    void **items;\r\n    int *conditions;\r\n\r\n    size_t (*hash)(const void *);\r\n\r\n    bool (*equals)(const void *, const void *);\r\n} SET;\r\n\r\nvoid *set_resize(void *set, size_t new_setSize) {\r\n    SET *pSet = set;\r\n    void **new_items = calloc(new_setSize, new_setSize * sizeof(size_t));\r\n    if (new_items == NULL) {\r\n        return NULL;\r\n    }\r\n    int *new_conditions = calloc(new_setSize, new_setSize * sizeof(int));\r\n    if (new_conditions == NULL) {\r\n        return NULL;\r\n    }\r\n    int i;\r\n    for (i = 0; i < new_setSize; i++) {\r\n        new_conditions[i] = 0;\r\n    }\r\n    size_t clone_id;\r\n    for (i = 0; i < pSet->setSize; i++) {\r\n        clone_id = pSet->hash(pSet->items[i]) % new_setSize;\r\n        if (new_conditions[clone_id] == 0) {\r\n            new_items[clone_id] = pSet->items[i];\r\n            new_conditions[clone_id] = 1;\r\n        } else if (new_conditions[clone_id] == 1) {\r\n            if (pSet->equals(pSet->items[i], new_items[clone_id]) == false) {\r\n                size_t j;\r\n                for (j = clone_id + 1; j < new_setSize; j++) {\r\n                    if (new_conditions[j] == 0) {\r\n                        new_items[j] = pSet->items[i];\r\n                        new_conditions[j] = 1;\r\n                    } else if (new_conditions[j] == 1) {\r\n                        continue;\r\n                    }\r\n                }\r\n                for (j = 0; j < clone_id; j++) {\r\n                    if (new_conditions[j] == 0) {\r\n                        new_items[j] = pSet->items[i];\r\n                        new_conditions[j] = 1;\r\n                    } else if (new_conditions[j] == 1) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    free(pSet->items);\r\n    free(pSet->conditions);\r\n    pSet->items = new_items;\r\n    pSet->conditions = new_conditions;\r\n    return pSet;\r\n}\r\n\r\nvoid *set_item_create(size_t itemSize) {\r\n    if (itemSize == 0) {\r\n        return NULL;\r\n    }\r\n    void *new_item = calloc(1, itemSize);\r\n    if (new_item == NULL) {\r\n        return NULL;\r\n    }\r\n    return new_item;\r\n}\r\n\r\nstatic void *set_destroy_each_item(void *set, void (*destroy)(void *)) {\r\n    SET *pSet = set;\r\n    int i;\r\n    for (i = 0; i < pSet->setSize; i++) {\r\n        if (pSet->conditions[i] == 1) {\r\n            if (destroy == NULL) {\r\n                pSet->items[i] = NULL;\r\n            } else {\r\n                destroy(pSet->items[i]);\r\n            }\r\n            free(pSet->items[i]);\r\n            pSet->conditions[i] = 0;\r\n        }\r\n    }\r\n    return pSet;\r\n}\r\n\r\n///*Создать новое пустое множество.\r\n///*Размер элемента -- itemSize, для обработки элементов использовать функцию хеширования hash,\r\n///*и функцию проверки на равенство equals.*\r\nvoid *set_create(size_t itemSize, size_t hash(const void *), bool (*equals)(const void *, const void *)) {\r\n    SET *pSet;\r\n    pSet = malloc(sizeof(SET));\r\n    if (pSet == NULL) {\r\n        return NULL;\r\n    }\r\n    if (itemSize == 0 || hash == NULL || equals == NULL) {\r\n        free(pSet);\r\n        return NULL;\r\n    }\r\n    pSet->itemSize = itemSize;\r\n    pSet->setSize = MIN_SIZE;\r\n    pSet->hash = hash;\r\n    pSet->equals = equals;\r\n    pSet->items = calloc(pSet->setSize, sizeof(size_t));\r\n    if (pSet->items == NULL) {\r\n        return NULL;\r\n    }\r\n    pSet->conditions = calloc(pSet->setSize, sizeof(int));\r\n    if (pSet->conditions == NULL) {\r\n        return NULL;\r\n    }\r\n    for (int i = 0; i < pSet->setSize; i++) {\r\n        pSet->conditions[i] = 0;\r\n    }\r\n    return pSet;\r\n}\r\n\r\n///*Удалить существующее множество.\r\n///*Если указана функция destroy,\r\n///*то вызвать её для каждого удаляемого элемента множества.*///\r\nvoid set_destroy(void *set, void (*destroy)(void *)) {\r\n    if (set == NULL) {\r\n        return;\r\n    }\r\n    SET *pSet = set_destroy_each_item(set, destroy);\r\n    pSet->equals = NULL;\r\n    pSet->hash = NULL;\r\n    pSet->itemSize = INVALID;\r\n    pSet->setSize = INVALID;\r\n    free(pSet->items);\r\n    free(pSet->conditions);\r\n    free(pSet);\r\n}\r\n\r\n///*Инициализировать множество новыми параметрами.\r\n///*Если set содержит элементы, то сначала удалить все элементы,\r\n///*потом инициализировать множество с учетом новых параметров.\r\n///*Размер элемента -- itemSize, для обработки элементов использовать функцию хеширования hash,\r\n///*и функцию проверки на равенство equals. Если указана функция destroy, то вызвать её для каждого удаляемого элемента.///\r\nvoid *set_init(void *set, size_t itemSize, size_t hash(const void *), bool (*equals)(const void *, const void *),\r\n               void (*destroy)(void *)) {\r\n    if (set == NULL || itemSize == 0 || hash == NULL || equals == NULL) {\r\n        return NULL;\r\n    }\r\n    SET *pSet = set_destroy_each_item(set, destroy);\r\n    pSet->equals = equals;\r\n    pSet->hash = hash;\r\n    pSet->itemSize = itemSize;\r\n    pSet->setSize = MIN_SIZE;\r\n\r\n    void **new_items = realloc(pSet->items, pSet->setSize * sizeof(size_t));\r\n    if (new_items == NULL) {\r\n        return NULL;\r\n    }\r\n    free(pSet->items);\r\n    pSet->items = new_items;\r\n\r\n    int *new_conditions = realloc(pSet->conditions, pSet->setSize * sizeof(int));\r\n    if (new_conditions == NULL) {\r\n        return NULL;\r\n    }\r\n    free(pSet->conditions);\r\n    pSet->conditions = new_conditions;\r\n\r\n    for (int i = 0; i < pSet->setSize; i++) {\r\n        pSet->conditions[i] = 0;\r\n    }\r\n\r\n    return pSet;\r\n}\r\n\r\n///*Удалить все элементы из множества.\r\n///*Если указана функция destroy,\r\n///*то вызвать её для каждого удаляемого элемента множества.///\r\nvoid set_clear(void *set, void (*destroy)(void *)) {\r\n    if (set == NULL) {\r\n        return;\r\n    }\r\n    SET *pSet = set_destroy_each_item(set, destroy);\r\n    for (int i = 0; i < pSet->setSize; i++) {\r\n        pSet->conditions[i] = 0;\r\n    }\r\n}\r\n\r\n///*Количество элементов во множестве.\r\n///*В случае, если set равен NULL, возвращает INVALID константу.///\r\nsize_t set_count(const void *set) {\r\n    if (set == NULL) {\r\n        return INVALID;\r\n    }\r\n    SET const *pSet = set;\r\n    int i;\r\n    int amount = 0;\r\n    for (i = 0; i < pSet->setSize; i++) {\r\n        if (pSet->conditions[i] == 1) {\r\n            amount++;\r\n        } else if (pSet->conditions[i] == 0) {\r\n            break;\r\n        }\r\n    }\r\n    return amount;\r\n}\r\n\r\n///*Проверить наличие во множестве заданного элемента.///\r\nbool set_contains(const void *set, const void *item) {\r\n    if (set == NULL) {\r\n        return NULL;\r\n    }\r\n    SET const *pSet = set;\r\n    size_t contain_id = pSet->hash(item) % pSet->setSize;\r\n    int i;\r\n    for (i = contain_id; i < pSet->setSize; contain_id++) {\r\n        if (pSet->equals(pSet->items[i], item) == true) {\r\n            return true;\r\n        } else {\r\n            continue;\r\n        }\r\n    }\r\n    for (i = 0; i < contain_id; i++) {\r\n        if (pSet->equals(pSet->items[i], item) == true) {\r\n            return true;\r\n        } else {\r\n            continue;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n///*Добавить новый элемент.\r\n///*В случае успеха, функция возвращает true,\r\n///*если такой элемент уже существует -- false.\r\nbool set_insert(void *set, const void *item) {\r\n    if (set == NULL) {\r\n        return INVALID;\r\n    }\r\n    SET *pSet = set;\r\n    size_t insert_id = pSet->hash(item) % pSet->setSize;\r\n    int i;\r\n    for (i = insert_id; i < pSet->setSize; insert_id++) {\r\n        if (pSet->conditions[i] == 1) {\r\n            if (pSet->equals(pSet->items[i], item) == true) {\r\n                return false;\r\n            } else {\r\n                continue;\r\n            }\r\n        } else if (pSet->conditions[i] == 0) {\r\n\r\n            pSet->items[i] = (void *) item;\r\n            pSet->conditions[i] = 1;\r\n            return true;\r\n        }\r\n    }\r\n    for (i = 0; i < insert_id; i++) {\r\n        if (pSet->conditions[i] == 1) {\r\n            if (pSet->equals(pSet->items[i], item) == true) {\r\n                return false;\r\n            } else {\r\n                continue;\r\n            }\r\n        } else if (pSet->conditions[i] == 0) {\r\n            pSet->items[i] = set_item_create(pSet->itemSize);\r\n            if (pSet->items[i] != NULL) {\r\n                pSet->items[i] = (void *) item;\r\n            } else {\r\n                return INVALID;\r\n            }\r\n            pSet->conditions[i] = 1;\r\n            return true;\r\n        }\r\n    }\r\n    pSet = set_resize(set, pSet->setSize * 2);\r\n    set_insert(pSet, item);\r\n}\r\n\r\n///*Найти элемент и удалить из множества.\r\n///*Если указана функция destroy, то вызвать её для удаляемого элемента setItem.///\r\nvoid set_remove(void *set, const void *item, void (*destroy)(void *)) {\r\n    if (set == NULL) {\r\n        return;\r\n    }\r\n    SET *pSet = set;\r\n    size_t remove_id = pSet->hash(item) % pSet->setSize;\r\n    if (pSet->conditions[remove_id] == 1) {\r\n        if (destroy != NULL) {\r\n            (*destroy)(&(pSet->items[remove_id]));\r\n            free(pSet->items[remove_id]);\r\n            pSet->conditions[remove_id] = 0;\r\n        } else if (destroy == NULL) {\r\n            pSet->items[remove_id] = NULL;\r\n            free(pSet->items[remove_id]);\r\n            pSet->conditions[remove_id] = 0;\r\n        }\r\n    }\r\n\r\n    size_t not_NULL_item = 0;\r\n    int i;\r\n    for (i = 0; i < pSet->setSize; i++) {\r\n        if (pSet->conditions[i] == 1) {\r\n            not_NULL_item++;\r\n        }\r\n    }\r\n\r\n    if (not_NULL_item < pSet->setSize / 2) {\r\n        pSet = set_resize(pSet, pSet->setSize / 2);\r\n    }\r\n}\r\n\r\n///*Идентификатор для первого элемента множества.\r\n///*Идентификатор может стать невалидным при модификации множества.*///\r\nsize_t set_first(const void *set) {\r\n    if (set == NULL) {\r\n        return INVALID;\r\n    }\r\n    SET const *pSet = set;\r\n    size_t item_id;\r\n    for (item_id = 0; item_id < pSet->setSize; item_id++) {\r\n        if (pSet->conditions[item_id] == 1) {\r\n            return item_id;\r\n        } else {\r\n            continue;\r\n        }\r\n    }\r\n    return set_stop(pSet);\r\n}\r\n\r\n///*Идентификатор для последнего элемента множества.\r\n///*Идентификатор может стать невалидным при модификации множества.*///\r\nsize_t set_last(const void *set) {\r\n    if (set == NULL) {\r\n        return (size_t) NULL;\r\n    }\r\n    SET const *pSet = set;\r\n    size_t item_id;\r\n    for (item_id = pSet->setSize - 1; item_id >= 0; item_id--) {\r\n        if (pSet->conditions[item_id] == 1) {\r\n            return item_id;\r\n        } else {\r\n            continue;\r\n        }\r\n    }\r\n    return set_stop(pSet);\r\n}\r\n\r\n///*По идентификатору текущего элемента получить\r\n///*идентификатор следующего элемента множества.*///\r\nsize_t set_next(const void *set, size_t item_id) {\r\n    if (set == NULL) {\r\n        return INVALID;\r\n    }\r\n    SET const *pSet = set;\r\n    size_t current_id = item_id % pSet->setSize;\r\n    if (current_id == pSet->setSize - 1) { //No place after\r\n        return set_stop(pSet);\r\n    }\r\n    for (int i = 1; i < pSet->setSize - current_id; i++) {\r\n        if (pSet->conditions[item_id + i] == 1) {\r\n            return current_id + i;\r\n        } else continue;\r\n    }\r\n    return set_stop(pSet);\r\n}\r\n\r\n///*По идентификатору текущего элемента получить\r\n///*идентификатор предыдущего элемента множества.*///\r\nsize_t set_prev(const void *set, size_t item_id) {\r\n    if (set == NULL) {\r\n        return INVALID;\r\n    }\r\n    SET const *pSet = set;\r\n    size_t current_id = item_id % pSet->setSize;\r\n    if (current_id == 0) { //No place before\r\n        return set_stop(pSet);\r\n    }\r\n    for (int i = 0; i < current_id; i++) {\r\n        if (pSet->conditions[current_id - i] == 1) {\r\n            return current_id - i;\r\n        } else continue;\r\n    }\r\n    return INVALID;\r\n}\r\n\r\n///*Идентификатор, получаемый при попытке\r\n///*обратиться к элементу за пределами множества.*///\r\nsize_t set_stop(const void *set) {\r\n    return INVALID - 1;\r\n}\r\n\r\n///*Получить указатель на элемент по его идентификатору.*///\r\nconst void *set_current(const void *set, size_t item_id) {\r\n    SET const *pSet = set;\r\n    if (pSet == NULL || item_id >= pSet->setSize || pSet->conditions[item_id] == 0) {\r\n        return NULL;\r\n    }\r\n    return (pSet->items[item_id]);\r\n}\r\n\r\n///*Удаление элемента множества по его идентификатору.\r\n///*Если указана функция destroy, то вызвать её для удаляемого элемента множества.\r\n///*После удаления элемента,\r\n///*идентификаторы любых элементов из этого множества могут стать невалидным.///\r\nvoid set_erase(void *set, size_t item_id, void (*destroy)(void *)) {\r\n    if (set == NULL) {\r\n        return;\r\n    }\r\n    SET const *pSet = set;\r\n    if (pSet->conditions[item_id] == 1) {\r\n        if (destroy != NULL) {\r\n            (*destroy)(&(pSet->items[item_id]));\r\n            free(pSet->items[item_id]);\r\n            pSet->conditions[item_id] = 0;\r\n        } else if (destroy == NULL) {\r\n            pSet->items[item_id] = NULL;\r\n            free(pSet->items[item_id]);\r\n            pSet->conditions[item_id] = 0;\r\n        }\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/set.c b/set.c
--- a/set.c	(revision 90bfea4c5c6d27e7ae4342b7a356f762920e4d79)
+++ b/set.c	(date 1615227484886)
@@ -310,7 +310,7 @@
     }
 
     if (not_NULL_item < pSet->setSize / 2) {
-        pSet = set_resize(pSet, pSet->setSize / 2);
+        set_resize(pSet, pSet->setSize / 2);
     }
 }
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"CMakeRunConfigurationManager\" shouldGenerate=\"true\" shouldDeleteObsolete=\"true\">\r\n    <generated>\r\n      <config projectName=\"set\" targetName=\"set\" />\r\n    </generated>\r\n  </component>\r\n  <component name=\"CMakeSettings\">\r\n    <configurations>\r\n      <configuration PROFILE_NAME=\"Debug\" CONFIG_NAME=\"Debug\" ENABLED=\"true\" />\r\n    </configurations>\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"808d62af-7c91-4acf-93ca-453d1dae730f\" name=\"Default Changelist\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/set.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/set.c\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ClangdSettings\">\r\n    <option name=\"formatViaClangd\" value=\"false\" />\r\n  </component>\r\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1pR9mph75lfrBK1ERnevIxgFwFO\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"cf.first.check.clang-format\" value=\"false\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"CPPToolchains\" />\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"set\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"set\" TARGET_NAME=\"set\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"set\" RUN_TARGET_NAME=\"set\">\r\n      <method v=\"2\">\r\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"GradleAppRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\">\r\n      <method v=\"2\">\r\n        <option name=\"com.jetbrains.cidr.cpp.gradle.execution.GradleNativeBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"808d62af-7c91-4acf-93ca-453d1dae730f\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1615135200233</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1615135200233</updated>\r\n      <workItem from=\"1615135209008\" duration=\"1276000\" />\r\n      <workItem from=\"1615217673761\" duration=\"3410000\" />\r\n      <workItem from=\"1615223925193\" duration=\"2186000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Гит хуета, сломалось все 10 раз.\">\r\n      <created>1615135406633</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615135406633</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Failure on set_destroy.\">\r\n      <created>1615136239673</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615136239674</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Need to realize create throw init.\">\r\n      <created>1615221037331</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615221037331</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"4\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Гит хуета, сломалось все 10 раз.\" />\r\n    <MESSAGE value=\"Failure on set_destroy.\" />\r\n    <MESSAGE value=\"Need to realize create throw init.\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Need to realize create throw init.\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 90bfea4c5c6d27e7ae4342b7a356f762920e4d79)
+++ b/.idea/workspace.xml	(date 1615227526491)
@@ -62,7 +62,7 @@
       <updated>1615135200233</updated>
       <workItem from="1615135209008" duration="1276000" />
       <workItem from="1615217673761" duration="3410000" />
-      <workItem from="1615223925193" duration="2186000" />
+      <workItem from="1615223925193" duration="2470000" />
     </task>
     <task id="LOCAL-00001" summary="Гит хуета, сломалось все 10 раз.">
       <created>1615135406633</created>
@@ -85,7 +85,14 @@
       <option name="project" value="LOCAL" />
       <updated>1615221037331</updated>
     </task>
-    <option name="localTasksCounter" value="4" />
+    <task id="LOCAL-00004" summary="Need to realize create throw init. Small changes inside insert.">
+      <created>1615227318191</created>
+      <option name="number" value="00004" />
+      <option name="presentableId" value="LOCAL-00004" />
+      <option name="project" value="LOCAL" />
+      <updated>1615227318191</updated>
+    </task>
+    <option name="localTasksCounter" value="5" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -104,6 +111,7 @@
     <MESSAGE value="Гит хуета, сломалось все 10 раз." />
     <MESSAGE value="Failure on set_destroy." />
     <MESSAGE value="Need to realize create throw init." />
-    <option name="LAST_COMMIT_MESSAGE" value="Need to realize create throw init." />
+    <MESSAGE value="Need to realize create throw init. Small changes inside insert." />
+    <option name="LAST_COMMIT_MESSAGE" value="Need to realize create throw init. Small changes inside insert." />
   </component>
 </project>
\ No newline at end of file
