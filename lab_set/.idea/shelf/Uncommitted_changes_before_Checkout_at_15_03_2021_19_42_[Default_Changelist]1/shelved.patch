Index: ../set/main.c
===================================================================
diff --git a/../set/main.c b/../set/main.c
deleted file mode 100644
--- a/../set/main.c	
+++ /dev/null	
@@ -1,124 +0,0 @@
-#define _CRTDBG_MAP_ALLOC
-#include <string.h>
-#include <assert.h>
-#include "set.h"
-#include <crtdbg.h>
-
-typedef struct {
-    char name[10];
-} KeyValue;
-
-static size_t hash(const void* ptr) {
-    const int p = 31;
-    const int m = 1e9 + 9;
-    size_t hash_value = 0;
-    size_t p_pow = 1;
-
-    const KeyValue* keyValue = (const KeyValue*)ptr;
-
-    for (size_t i = 0; i < 10; ++i) {
-        const char c = keyValue->name[i];
-        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;
-        p_pow = (p_pow * p) % m;
-    }
-
-    return hash_value;
-}
-
-static bool equals(const void* lhsp, const void* rhsp) {
-    const KeyValue* lhs = (const KeyValue*)lhsp;
-    const KeyValue* rhs = (const KeyValue*)rhsp;
-
-    return 0 == strcmp(lhs->name, rhs->name);
-}
-
-int main()
-{
-    //Создаем множество с элементами типа KeyValue;
-    void *set = set_create(1, hash, equals);
-    //Создаем ключ-значение для множества
-    const KeyValue keyValue = {"Key-value"};
-    const KeyValue keyValue1 = {"Key-valu1"};
-    const KeyValue keyValue2 = {"Key-valu2"};
-    const KeyValue keyValue3 = {"Key-valu3"};
-    const KeyValue keyValue4 = {"Key-valu4"};
-    const KeyValue keyValue5 = {"Key-valu5"};
-    set = set_init(set, sizeof(KeyValue), hash, equals, NULL);
-    assert(set_init(NULL, 8, hash, equals, NULL) == NULL);
-    set_erase(set, (size_t) &keyValue, NULL);
-    assert(set_contains(set, NULL) == false);
-    assert(set_next(set, (size_t) &keyValue) == set_stop(set));
-    assert(set_prev(set, (size_t) &keyValue) == set_stop(set));
-    assert(set_last(set) == set_stop(set));
-    assert(set_first(set) == set_stop(set));
-    assert(set_insert(set, NULL) == false);
-    assert(set_insert(NULL, &keyValue) == false);
-    assert(0 == set_count(set));
-    assert(set_stop(set) == set_first(set));
-    assert(set_stop(set) == set_last(set));
-    assert(set_next(NULL, 2) == set_stop(NULL));
-    assert(set_next(set, set_first(set)) == set_stop(set));
-    assert(set_next(set, set_last(set)) == set_stop(set));
-    assert(set_prev(set, set_first(set)) == set_stop(set));
-    assert(set_prev(set, set_last(set)) == set_stop(set));
-    assert(set_contains(set, &keyValue) == false);
-    assert(set_stop(set) + 1 == set_count(NULL));
-
-    assert(set_insert(set, &keyValue));
-    assert(set_count(set) == 1);
-    assert(set_first(set) == set_last(set));
-
-
-    assert(set_insert(set, &keyValue1));
-    assert(set_count(set) == 2);
-    assert(set_insert(set, &keyValue2));
-    assert(set_count(set) == 3);
-    assert(set_insert(set, &keyValue3));
-    assert(set_count(set) == 4);
-    assert(set_insert(set, &keyValue4));
-    assert(set_count(set) == 5);
-    assert(set_insert(set, &keyValue5));
-    assert(set_count(set) == 6);
-    set_remove(set, &keyValue,NULL);
-    assert(set_count(set) == 5);
-    set_clear(set, NULL);
-    size_t y = set_stop(set);
-    size_t x = set_first(set);
-    assert(set_stop(set) == set_first(set));
-    assert(set_insert(set, NULL) == false);
-
-
-    //Добавляем ключ-значение
-    const bool isCreated = (KeyValue *) set_insert(set, &keyValue);
-    assert(true == isCreated);
-
-    assert(true == set_contains(set, &keyValue));
-    const KeyValue *item = (const KeyValue *) set_current(set, set_first(set));
-
-    assert(0 == strcmp(item->name, keyValue.name));
-
-    assert(set_last(set) == set_first(set));
-
-    assert(set_next(set, set_first(set)) == set_stop(set));
-
-    set_erase(set, hash(&keyValue), NULL);
-    assert(set_contains(set, &keyValue) == false);
-    assert(set_count(set) == 0);
-    assert(set_count(NULL) == -1);
-
-    set_destroy(set, NULL);
-
-    // Send all reports to STDOUT
-    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
-    _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
-    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
-    _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
-    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
-    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);
-
-    _CrtDumpMemoryLeaks();
-
-
-    return 0;
-
-}
\ No newline at end of file
Index: ../set/set.h
===================================================================
diff --git a/../set/set.h b/../set/set.h
deleted file mode 100644
--- a/../set/set.h	
+++ /dev/null	
@@ -1,24 +0,0 @@
-#ifndef SET_SET_H
-#define SET_SET_H
-#include <stdbool.h> // bool
-#include <stddef.h>  // size_t
-
-static const size_t INVALID = ~((size_t)0);
-
-void* set_create(size_t itemSize, size_t hash(const void*), bool (*equals)(const void*, const void*));
-void set_destroy(void* set, void (*destroy)(void*));
-void* set_init(void* set, size_t itemSize, size_t hash(const void*), bool (*equals)(const void*, const void*),
-               void (*destroy)(void*));
-void set_clear(void* set, void (*destroy)(void*));
-size_t set_count(const void* set);
-bool set_contains(const void* set, const void* item);
-bool set_insert(void* set, const void* item);
-void set_remove(void* set, const void* item, void (*destroy)(void*));
-size_t set_first(const void* set);
-size_t set_last(const void* set);
-size_t set_next(const void* set, size_t item_id);
-size_t set_prev(const void* set, size_t item_id);
-size_t set_stop(const void* set);
-const void* set_current(const void* set, size_t item_id);
-void set_erase(void* set, size_t erase_id, void (*destroy)(void*));
-#endif //SET_SET_H
Index: ../lab_chat_bot/.idea/workspace.xml
===================================================================
diff --git a/../lab_chat_bot/.idea/workspace.xml b/../lab_chat_bot/.idea/workspace.xml
deleted file mode 100644
--- a/../lab_chat_bot/.idea/workspace.xml	
+++ /dev/null	
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="CMakeRunConfigurationManager" shouldGenerate="true" shouldDeleteObsolete="true">
-    <generated />
-  </component>
-  <component name="CMakeSettings">
-    <configurations>
-      <configuration PROFILE_NAME="Debug" CONFIG_NAME="Debug" ENABLED="true" />
-    </configurations>
-  </component>
-  <component name="ChangeListManager">
-    <list default="true" id="0476bf84-66d0-46fe-b48c-8d6505e5437d" name="Default Changelist" comment="Started.">
-      <change afterPath="$PROJECT_DIR$/.idea/lab_chat_bot.iml" afterDir="false" />
-    </list>
-    <option name="SHOW_DIALOG" value="false" />
-    <option name="HIGHLIGHT_CONFLICTS" value="true" />
-    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
-    <option name="LAST_RESOLUTION" value="IGNORE" />
-  </component>
-  <component name="ClangdSettings">
-    <option name="formatViaClangd" value="false" />
-  </component>
-  <component name="Git.Settings">
-    <option name="RECENT_BRANCH_BY_REPOSITORY">
-      <map>
-        <entry key="$PROJECT_DIR$/.." value="lab_chat_bot" />
-      </map>
-    </option>
-    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
-  </component>
-  <component name="ProjectId" id="1pPgCtB1BNjZKaMjyiisHMh7ked" />
-  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
-  <component name="ProjectViewState">
-    <option name="hideEmptyMiddlePackages" value="true" />
-    <option name="showLibraryContents" value="true" />
-  </component>
-  <component name="PropertiesComponent">
-    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
-    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
-    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
-    <property name="WebServerToolWindowFactoryState" value="false" />
-    <property name="cf.first.check.clang-format" value="false" />
-    <property name="settings.editor.selected.configurable" value="CPPToolchains" />
-  </component>
-  <component name="RunManager">
-    <configuration default="true" type="CLionExternalRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true">
-      <method v="2">
-        <option name="CLION.EXTERNAL.BUILD" enabled="true" />
-      </method>
-    </configuration>
-    <configuration default="true" type="GradleAppRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true">
-      <method v="2">
-        <option name="com.jetbrains.cidr.cpp.gradle.execution.GradleNativeBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
-      </method>
-    </configuration>
-  </component>
-  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
-  <component name="TaskManager">
-    <task active="true" id="Default" summary="Default task">
-      <changelist id="0476bf84-66d0-46fe-b48c-8d6505e5437d" name="Default Changelist" comment="" />
-      <created>1615090014785</created>
-      <option name="number" value="Default" />
-      <option name="presentableId" value="Default" />
-      <updated>1615090014785</updated>
-      <workItem from="1615090018385" duration="249000" />
-    </task>
-    <task id="LOCAL-00001" summary="Started.">
-      <created>1615090062354</created>
-      <option name="number" value="00001" />
-      <option name="presentableId" value="LOCAL-00001" />
-      <option name="project" value="LOCAL" />
-      <updated>1615090062354</updated>
-    </task>
-    <option name="localTasksCounter" value="2" />
-    <servers />
-  </component>
-  <component name="Vcs.Log.Tabs.Properties">
-    <option name="TAB_STATES">
-      <map>
-        <entry key="MAIN">
-          <value>
-            <State />
-          </value>
-        </entry>
-      </map>
-    </option>
-  </component>
-  <component name="VcsManagerConfiguration">
-    <MESSAGE value="Started." />
-    <option name="LAST_COMMIT_MESSAGE" value="Started." />
-  </component>
-</project>
\ No newline at end of file
Index: ../set/set.c
===================================================================
diff --git a/../set/set.c b/../set/set.c
deleted file mode 100644
--- a/../set/set.c	
+++ /dev/null	
@@ -1,441 +0,0 @@
-#include "set.h"
-#include <stdlib.h>
-#include <vcruntime_string.h>
-
-static const size_t MIN_SIZE = 0;
-
-typedef struct SET {
-    size_t itemSize;
-    size_t setSize;
-    void **items;
-    int *conditions;
-
-    size_t (*hash)(const void *);
-
-    bool (*equals)(const void *, const void *);
-} SET;
-
-static void *set_resize(void *set, size_t new_setSize) {
-    SET *pSet = set;
-    void **new_items = calloc(new_setSize, new_setSize * sizeof(size_t));
-    if (new_items == NULL) {
-        return NULL;
-    }
-    int *new_conditions = calloc(new_setSize, new_setSize * sizeof(int));
-    if (new_conditions == NULL) {
-        return NULL;
-    }
-    if (new_setSize == 0) {
-        pSet->setSize = 0;
-        set_destroy(pSet, NULL);
-        free(pSet->items);
-        free(pSet->conditions);
-        pSet->items = new_items;
-        pSet->conditions = new_conditions;
-        return pSet;
-    }
-    int i;
-    size_t clone_id;
-    for (i = 0; i < pSet->setSize; i++) {
-        clone_id = pSet->hash(pSet->items[i]) % new_setSize;
-        if (new_conditions[clone_id] == 0) {
-            new_items[clone_id] = pSet->items[i];
-            if (pSet->conditions[i] == 1) {
-                new_conditions[clone_id] = 1;
-            }
-        } else if (new_conditions[clone_id] == 1) {
-            if (pSet->equals(pSet->items[i], new_items[clone_id]) == false) {
-                size_t j;
-                for (j = clone_id + 1; j < new_setSize; j++) {
-                    if (new_conditions[j] == 0) {
-                        new_items[j] = pSet->items[i];
-                        if (pSet->conditions[i] == 1) {
-                            new_conditions[j] = 1;
-                        }
-                        break;
-                    } else if (new_conditions[j] == 1) {
-                        continue;
-                    }
-                }
-                for (j = 0; j < clone_id; j++) {
-                    if (new_conditions[j] == 0) {
-                        new_items[j] = pSet->items[i];
-                        if (pSet->conditions[i] == 1) {
-                            new_conditions[j] = 1;
-                        }
-                        break;
-                    } else if (new_conditions[j] == 1) {
-                        continue;
-                    }
-                }
-            }
-        }
-    }
-    free(pSet->items);
-    free(pSet->conditions);
-    pSet->setSize = new_setSize;
-    pSet->items = new_items;
-    pSet->conditions = new_conditions;
-    return pSet;
-}
-
-static void *set_item_create(size_t itemSize) {
-    if (itemSize == 0) {
-        return NULL;
-    }
-    void *new_item = calloc(1, itemSize);
-    if (new_item == NULL) {
-        return NULL;
-    }
-    return new_item;
-}
-
-static void set_destroy_each_item(void *set, void (*destroy)(void *)) {
-    SET *pSet = set;
-    int i;
-    for (i = 0; i < pSet->setSize; i++) {
-        if (pSet->conditions[i] == 1) {
-            if (destroy) {
-                destroy(pSet->items[i]);
-            }
-            free(pSet->items[i]);
-            pSet->conditions[i] = 0;
-        }
-    }
-}
-
-static const size_t find_place(const void *set, const void *item) {
-    const SET *pSet = set;
-    size_t item_id = pSet->hash(item) % pSet->setSize;
-    size_t i;
-    for (i = item_id; i < pSet->setSize; i++) {
-        if (pSet->conditions[i] == 1) {
-            if (pSet->equals(pSet->items[i], item) == true) {
-                return INVALID;
-            } else {
-                continue;
-            }
-        } else if (pSet->conditions[i] == 0) {
-            return i;
-        }
-    }
-    for (i = 0; i < item_id; i++) {
-        if (pSet->conditions[i] == 1) {
-            if (pSet->equals(pSet->items[i], item) == true) {
-                return INVALID;
-            } else {
-                continue;
-            }
-        } else if (pSet->conditions[i] == 0) {
-            return i;
-        }
-    }
-    return set_stop(pSet);
-}
-
-///*Создать новое пустое множество.
-///*Размер элемента -- itemSize, для обработки элементов использовать функцию хеширования hash,
-///*и функцию проверки на равенство equals.*
-void *set_create(size_t itemSize, size_t hash(const void *), bool (*equals)(const void *, const void *)) {
-    if (itemSize == 0 || hash == NULL || equals == NULL) {
-        return NULL;
-    }
-    SET *pSet;
-    pSet = malloc(sizeof(SET));
-    if (pSet == NULL) {
-        return NULL;
-    }
-    pSet->itemSize = itemSize;
-    pSet->setSize = MIN_SIZE;
-    pSet->hash = hash;
-    pSet->equals = equals;
-    pSet->items = calloc(pSet->setSize, sizeof(size_t));
-    if (pSet->items == NULL) {
-        return NULL;
-    }
-    pSet->conditions = calloc(pSet->setSize, sizeof(int));
-    if (pSet->conditions == NULL) {
-        return NULL;
-    }
-    return pSet;
-}
-
-///*Удалить существующее множество.
-///*Если указана функция destroy,
-///*то вызвать её для каждого удаляемого элемента множества.*///
-void set_destroy(void *set, void (*destroy)(void *)) {
-    if (set == NULL) {
-        return;
-    }
-    SET *pSet = set;
-    set_destroy_each_item(pSet, destroy);
-    pSet->equals = NULL;
-    pSet->hash = NULL;
-    pSet->itemSize = INVALID;
-    pSet->setSize = INVALID;
-    free(pSet->items);
-    free(pSet->conditions);
-    free(pSet);
-}
-
-///*Инициализировать множество новыми параметрами.
-///*Если set содержит элементы, то сначала удалить все элементы,
-///*потом инициализировать множество с учетом новых параметров.
-///*Размер элемента -- itemSize, для обработки элементов использовать функцию хеширования hash,
-///*и функцию проверки на равенство equals. Если указана функция destroy, то вызвать её для каждого удаляемого элемента.///
-void *set_init(void *set, size_t itemSize, size_t hash(const void *), bool (*equals)(const void *, const void *),
-               void (*destroy)(void *)) {
-    if (set == NULL || itemSize == 0 || hash == NULL || equals == NULL) {
-        return NULL;
-    }
-    SET *pSet = set;
-    set_destroy_each_item(pSet, destroy);
-    free(pSet->items);
-    free(pSet->conditions);
-    free(pSet);
-    pSet = set_create(itemSize, hash, equals);
-    return pSet;
-}
-
-///*Удалить все элементы из множества.
-///*Если указана функция destroy,
-///*то вызвать её для каждого удаляемого элемента множества.///
-void set_clear(void *set, void (*destroy)(void *)) {
-    if (set == NULL) {
-        return;
-    }
-    SET *pSet = set;
-    set_destroy_each_item(pSet, destroy);
-    for (int i = 0; i < pSet->setSize; i++) {
-        pSet->conditions[i] = 0;
-    }
-}
-
-///*Количество элементов во множестве.
-///*В случае, если set равен NULL, возвращает INVALID константу.///
-size_t set_count(const void *set) {
-    if (set == NULL) {
-        return INVALID;
-    }
-    SET const *pSet = set;
-    int i;
-    int amount = 0;
-    for (i = 0; i < pSet->setSize; i++) {
-        if (pSet->conditions[i] == 1) {
-            amount++;
-        } else if (pSet->conditions[i] == 0) {
-            continue;
-        }
-    }
-    return amount;
-}
-
-///*Проверить наличие во множестве заданного элемента.///
-bool set_contains(const void *set, const void *item) {
-    if (set == NULL || item == NULL) {
-        return false;
-    }
-    SET const *pSet = set;
-    if (pSet->setSize == 0) {
-        return false;
-    }
-    size_t contain_id = pSet->hash(item) % pSet->setSize;
-    if (contain_id >= pSet->setSize) {
-        return false;
-    }
-    int i;
-    for (i = contain_id; i < pSet->setSize; i++) {
-        if (pSet->conditions[i] == 1) {
-            if (pSet->equals(pSet->items[i], item) == true) {
-                return true;
-            }
-        }
-    }
-    for (i = 0; i < contain_id; i++) {
-        if (pSet->conditions[i] == 1) {
-            if (pSet->equals(pSet->items[i], item) == true) {
-                return true;
-            }
-        }
-    }
-    return false;
-}
-
-///*Добавить новый элемент.
-///*В случае успеха, функция возвращает true,
-///*если такой элемент уже существует -- false.
-bool set_insert(void *set, const void *item) {
-    if (set == NULL || item == NULL) {
-        return false;
-    }
-    SET *pSet = set;
-    if (pSet->setSize == 0) {
-        set_resize(set, 2);
-    }
-    size_t insert_id = find_place(pSet, item);
-    if (insert_id == set_stop(pSet)) {
-        set = set_resize(set, pSet->setSize * 2);
-        return set_insert(pSet, item);
-    }
-    if (insert_id == INVALID) {
-        return false;
-    }
-    if (pSet->conditions[insert_id] == 0) {
-        pSet->items[insert_id] = set_item_create(pSet->itemSize);
-        if (pSet->items[insert_id] != NULL) {
-            memcpy(pSet->items[insert_id], item, pSet->itemSize);
-        } else {
-            return false;
-        }
-        pSet->conditions[insert_id] = 1;
-        return true;
-    }
-}
-
-///*Найти элемент и удалить из множества.
-///*Если указана функция destroy, то вызвать её для удаляемого элемента setItem.///
-void set_remove(void *set, const void *item, void (*destroy)(void *)) {
-    if (set == NULL || item == NULL) {
-        return;
-    }
-    SET *pSet = set;
-    if (pSet->setSize == 0) {
-        return;
-    }
-    size_t remove_id = pSet->hash(item) % pSet->setSize;
-    if (pSet->conditions[remove_id] == 1) {
-        if (destroy) {
-            destroy(pSet->items[remove_id]);
-        }
-        free(pSet->items[remove_id]);
-        pSet->conditions[remove_id] = 0;
-    }
-
-    if (set_count(pSet) < pSet->setSize / 2 && set_count(pSet) != 0) {
-        set = set_resize(pSet, pSet->setSize / 2);
-    }
-}
-
-///*Идентификатор для первого элемента множества.
-///*Идентификатор может стать невалидным при модификации множества.*///
-size_t set_first(const void *set) {
-    if (set == NULL) {
-        return set_stop(set);
-    }
-    SET const *pSet = set;
-    size_t item_id;
-    for (item_id = 0; item_id < pSet->setSize; item_id++) {
-        if (pSet->conditions[item_id] == 1) {
-            return item_id;
-        } else {
-            continue;
-        }
-    }
-    return set_stop(pSet);
-}
-
-///*Идентификатор для последнего элемента множества.
-///*Идентификатор может стать невалидным при модификации множества.*///
-size_t set_last(const void *set) {
-    if (set == NULL) {
-        return set_stop(set);
-    }
-    SET const *pSet = set;
-    if (pSet->setSize == 0) {
-        return set_stop(pSet);
-    }
-    size_t item_id;
-    for (item_id = pSet->setSize - 1; item_id > 0; item_id--) {
-        if (pSet->conditions[item_id] == 1) {
-            return item_id;
-        } else {
-            continue;
-        }
-    }
-    return set_stop(pSet);
-}
-
-///*По идентификатору текущего элемента получить
-///*идентификатор следующего элемента множества.*///
-size_t set_next(const void *set, size_t item_id) {
-    if (set == NULL) {
-        return set_stop(set);
-    }
-    SET const *pSet = set;
-    if (pSet->setSize == 0) {
-        return set_stop(pSet);
-    }
-    size_t current_id = item_id % pSet->setSize;
-    if (current_id == pSet->setSize - 1) { //No place after
-        return set_stop(pSet);
-    }
-    for (int i = 1; i < pSet->setSize - current_id; i++) {
-        if (pSet->conditions[item_id + i] == 1) {
-            return current_id + i;
-        } else continue;
-    }
-    return set_stop(pSet);
-}
-
-///*По идентификатору текущего элемента получить
-///*идентификатор предыдущего элемента множества.*///
-size_t set_prev(const void *set, size_t item_id) {
-    if (set == NULL) {
-        return set_stop(set);
-    }
-    SET const *pSet = set;
-    if (pSet->setSize == 0) {
-        return set_stop(pSet);
-    }
-    size_t current_id = item_id % pSet->setSize;
-    if (current_id == 0) { //No place before
-        return set_stop(pSet);
-    }
-    for (int i = 0; i < current_id; i++) {
-        if (pSet->conditions[current_id - i] == 1) {
-            return current_id - i;
-        } else continue;
-    }
-    return set_stop(pSet);
-}
-
-///*Идентификатор, получаемый при попытке
-///*обратиться к элементу за пределами множества.*///
-size_t set_stop(const void *set) {
-    return INVALID - 1;
-}
-
-///*Получить указатель на элемент по его идентификатору.*///
-const void *set_current(const void *set, size_t item_id) {
-    SET const *pSet = set;
-    if (pSet == NULL || item_id >= pSet->setSize || pSet->setSize == 0 || pSet->conditions[item_id] == 0) {
-        return NULL;
-    }
-    size_t current_id = item_id % pSet->setSize;
-    return (pSet->items[current_id]);
-}
-
-///*Удаление элемента множества по его идентификатору.
-///*Если указана функция destroy, то вызвать её для удаляемого элемента множества.
-///*После удаления элемента,
-///*идентификаторы любых элементов из этого множества могут стать невалидным.///
-void set_erase(void *set, size_t item_id, void (*destroy)(void *)) {
-    if (set == NULL) {
-        return;
-    }
-    SET const *pSet = set;
-    if (pSet->setSize == 0) {
-        return;
-    }
-    size_t erase_id = item_id % pSet->setSize;
-    if (erase_id > pSet->setSize - 1) {
-        return;
-    }
-    if (pSet->conditions[erase_id] == 1) {
-        if (destroy != NULL) {
-            destroy(pSet->items[erase_id]);
-        }
-        free(pSet->items[erase_id]);
-        pSet->conditions[erase_id] = 0;
-    }
-}
\ No newline at end of file
Index: ../lab_chat_bot/.idea/lab_chat_bot.iml
===================================================================
diff --git a/../lab_chat_bot/.idea/lab_chat_bot.iml b/../lab_chat_bot/.idea/lab_chat_bot.iml
deleted file mode 100644
--- a/../lab_chat_bot/.idea/lab_chat_bot.iml	
+++ /dev/null	
@@ -1,2 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module classpath="CMake" type="CPP_MODULE" version="4" />
\ No newline at end of file
Index: ../lab_chat_bot/.idea/misc.xml
===================================================================
diff --git a/../lab_chat_bot/.idea/misc.xml b/../lab_chat_bot/.idea/misc.xml
deleted file mode 100644
--- a/../lab_chat_bot/.idea/misc.xml	
+++ /dev/null	
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="CMakeWorkspace">
-    <contentRoot DIR="$PROJECT_DIR$" />
-  </component>
-</project>
\ No newline at end of file
Index: ../set/CMakeLists.txt
===================================================================
diff --git a/../set/CMakeLists.txt b/../set/CMakeLists.txt
deleted file mode 100644
--- a/../set/CMakeLists.txt	
+++ /dev/null	
@@ -1,6 +0,0 @@
-cmake_minimum_required(VERSION 3.17)
-project(set C)
-
-set(CMAKE_C_STANDARD 11)
-
-add_executable(set main.c set.c set.h)
\ No newline at end of file
Index: ../set/.idea/shelf/Uncommitted_changes_before_Checkout_at_15_03_2021_17_50__Default_Changelist_.xml
===================================================================
diff --git a/../set/.idea/shelf/Uncommitted_changes_before_Checkout_at_15_03_2021_17_50__Default_Changelist_.xml b/../set/.idea/shelf/Uncommitted_changes_before_Checkout_at_15_03_2021_17_50__Default_Changelist_.xml
deleted file mode 100644
--- a/../set/.idea/shelf/Uncommitted_changes_before_Checkout_at_15_03_2021_17_50__Default_Changelist_.xml	
+++ /dev/null	
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Checkout_at_15_03_2021_17_50_[Default_Changelist]" date="1615805432220" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_15_03_2021_17_50_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Checkout at 15.03.2021 17:50 [Default Changelist]" />
-</changelist>
\ No newline at end of file
