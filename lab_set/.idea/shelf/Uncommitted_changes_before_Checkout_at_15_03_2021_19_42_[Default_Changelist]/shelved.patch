Index: ../set/.idea/set.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../set/.idea/set.iml b/../set/.idea/set.iml
deleted file mode 100644
--- a/../set/.idea/set.iml	
+++ /dev/null	
@@ -1,2 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module classpath="CMake" type="CPP_MODULE" version="4" />
\ No newline at end of file
Index: ../set/.idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../set/.idea/modules.xml b/../set/.idea/modules.xml
deleted file mode 100644
--- a/../set/.idea/modules.xml	
+++ /dev/null	
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/.idea/set.iml" filepath="$PROJECT_DIR$/.idea/set.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
Index: ../set/.idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../set/.idea/misc.xml b/../set/.idea/misc.xml
deleted file mode 100644
--- a/../set/.idea/misc.xml	
+++ /dev/null	
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="CMakeWorkspace" PROJECT_DIR="$PROJECT_DIR$/../../list">
-    <contentRoot DIR="$PROJECT_DIR$" />
-  </component>
-</project>
\ No newline at end of file
Index: ../set/.idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../set/.idea/vcs.xml b/../set/.idea/vcs.xml
deleted file mode 100644
--- a/../set/.idea/vcs.xml	
+++ /dev/null	
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="VcsDirectoryMappings">
-    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
-  </component>
-</project>
\ No newline at end of file
Index: set.c
===================================================================
diff --git a/set.c b/set.c
new file mode 100644
--- /dev/null	
+++ b/set.c	
@@ -0,0 +1,472 @@
+#include "set.h"
+#include <stdlib.h>
+#include <vcruntime_string.h>
+
+static const size_t MIN_SIZE = 0;
+
+typedef struct SET {
+    size_t itemSize;
+    size_t setSize;
+    void **items;
+    int *conditions;
+
+    size_t (*hash)(const void *);
+
+    bool (*equals)(const void *, const void *);
+} SET;
+
+static void *set_resize(void *set, size_t new_setSize) {
+    SET *pSet = set;
+    void **new_items = calloc(new_setSize, new_setSize * sizeof(size_t));
+    if (new_items == NULL) {
+        return NULL;
+    }
+    int *new_conditions = calloc(new_setSize, new_setSize * sizeof(int));
+    if (new_conditions == NULL) {
+        return NULL;
+    }
+    if (new_setSize == 0) {
+        pSet->setSize = 0;
+        set_clear(pSet, NULL);
+        free(pSet->items);
+        free(pSet->conditions);
+        pSet->items = new_items;
+        pSet->conditions = new_conditions;
+        return pSet;
+    }
+    int i;
+    size_t clone_id;
+    for (i = 0; i < pSet->setSize; i++) {
+        clone_id = pSet->hash(pSet->items[i]) % new_setSize;
+        if (new_conditions[clone_id] == 0) {
+            new_items[clone_id] = pSet->items[i];
+            if (pSet->conditions[i] == 1) {
+                new_conditions[clone_id] = 1;
+            }
+        } else if (new_conditions[clone_id] == 1) {
+            if (pSet->equals(pSet->items[i], new_items[clone_id]) == false) {
+                size_t j;
+                for (j = clone_id + 1; j < new_setSize; j++) {
+                    if (new_conditions[j] == 0) {
+                        new_items[j] = pSet->items[i];
+                        if (pSet->conditions[i] == 1) {
+                            new_conditions[j] = 1;
+                        }
+                        break;
+                    } else if (new_conditions[j] == 1) {
+                        continue;
+                    }
+                }
+                for (j = 0; j < clone_id; j++) {
+                    if (new_conditions[j] == 0) {
+                        new_items[j] = pSet->items[i];
+                        if (pSet->conditions[i] == 1) {
+                            new_conditions[j] = 1;
+                        }
+                        break;
+                    } else if (new_conditions[j] == 1) {
+                        continue;
+                    }
+                }
+            }
+        }
+    }
+    free(pSet->items);
+    free(pSet->conditions);
+    pSet->setSize = new_setSize;
+    pSet->items = new_items;
+    pSet->conditions = new_conditions;
+    return pSet;
+}
+
+static void *set_item_create(size_t itemSize) {
+    if (itemSize == 0) {
+        return NULL;
+    }
+    void *new_item = calloc(1, itemSize);
+    if (new_item == NULL) {
+        return NULL;
+    }
+    return new_item;
+}
+
+static void set_destroy_each_item(void *set, void (*destroy)(void *)) {
+    SET *pSet = set;
+    int i;
+    for (i = 0; i < pSet->setSize; i++) {
+        if (pSet->conditions[i] == 1) {
+            if (destroy) {
+                destroy(pSet->items[i]);
+            }
+            free(pSet->items[i]);
+            pSet->conditions[i] = 0;
+        }
+    }
+}
+
+static const size_t find_place(const void *set, const void *item) {
+    const SET *pSet = set;
+    size_t item_id = pSet->hash(item) % pSet->setSize;
+    size_t i;
+    for (i = item_id; i < pSet->setSize; i++) {
+        if (pSet->conditions[i] == 1) {
+            if (pSet->equals(pSet->items[i], item) == true) {
+                return INVALID;
+            } else {
+                continue;
+            }
+        } else if (pSet->conditions[i] == 0) {
+            return i;
+        }
+    }
+    for (i = 0; i < item_id; i++) {
+        if (pSet->conditions[i] == 1) {
+            if (pSet->equals(pSet->items[i], item) == true) {
+                return INVALID;
+            } else {
+                continue;
+            }
+        } else if (pSet->conditions[i] == 0) {
+            return i;
+        }
+    }
+    return set_stop(pSet);
+}
+
+///*Создать новое пустое множество.
+///*Размер элемента -- itemSize, для обработки элементов использовать функцию хеширования hash,
+///*и функцию проверки на равенство equals.*
+void *set_create(size_t itemSize, size_t hash(const void *), bool (*equals)(const void *, const void *)) {
+    if (itemSize == 0 || hash == NULL || equals == NULL) {
+        return NULL;
+    }
+    SET *pSet;
+    pSet = malloc(sizeof(SET));
+    if (pSet == NULL) {
+        return NULL;
+    }
+    pSet->itemSize = itemSize;
+    pSet->setSize = MIN_SIZE;
+    pSet->hash = hash;
+    pSet->equals = equals;
+    pSet->items = calloc(pSet->setSize, sizeof(size_t));
+    if (pSet->items == NULL) {
+        return NULL;
+    }
+    pSet->conditions = calloc(pSet->setSize, sizeof(int));
+    if (pSet->conditions == NULL) {
+        return NULL;
+    }
+    return pSet;
+}
+
+///*Удалить существующее множество.
+///*Если указана функция destroy,
+///*то вызвать её для каждого удаляемого элемента множества.*///
+void set_destroy(void *set, void (*destroy)(void *)) {
+    if (set == NULL) {
+        return;
+    }
+    SET *pSet = set;
+    set_destroy_each_item(pSet, destroy);
+    pSet->equals = NULL;
+    pSet->hash = NULL;
+    pSet->itemSize = INVALID;
+    pSet->setSize = INVALID;
+    free(pSet->items);
+    free(pSet->conditions);
+    free(pSet);
+}
+
+///*Инициализировать множество новыми параметрами.
+///*Если set содержит элементы, то сначала удалить все элементы,
+///*потом инициализировать множество с учетом новых параметров.
+///*Размер элемента -- itemSize, для обработки элементов использовать функцию хеширования hash,
+///*и функцию проверки на равенство equals. Если указана функция destroy, то вызвать её для каждого удаляемого элемента.///
+void *set_init(void *set, size_t itemSize, size_t hash(const void *), bool (*equals)(const void *, const void *),
+               void (*destroy)(void *)) {
+    if (set == NULL || itemSize == 0 || hash == NULL || equals == NULL) {
+        return NULL;
+    }
+    SET *pSet = set;
+    set_destroy_each_item(pSet, destroy);
+    free(pSet->items);
+    free(pSet->conditions);
+    free(pSet);
+    pSet = set_create(itemSize, hash, equals);
+    return pSet;
+}
+
+///*Удалить все элементы из множества.
+///*Если указана функция destroy,
+///*то вызвать её для каждого удаляемого элемента множества.///
+void set_clear(void *set, void (*destroy)(void *)) {
+    if (set == NULL) {
+        return;
+    }
+    SET *pSet = set;
+    set_destroy_each_item(pSet, destroy);
+    for (int i = 0; i < pSet->setSize; i++) {
+        pSet->conditions[i] = 0;
+    }
+}
+
+///*Количество элементов во множестве.
+///*В случае, если set равен NULL, возвращает INVALID константу.///
+size_t set_count(const void *set) {
+    if (set == NULL) {
+        return INVALID;
+    }
+    SET const *pSet = set;
+    int i;
+    int amount = 0;
+    for (i = 0; i < pSet->setSize; i++) {
+        if (pSet->conditions[i] == 1) {
+            amount++;
+        } else if (pSet->conditions[i] == 0) {
+            continue;
+        }
+    }
+    return amount;
+}
+
+///*Проверить наличие во множестве заданного элемента.///
+bool set_contains(const void *set, const void *item) {
+    if (set == NULL || item == NULL) {
+        return false;
+    }
+    SET const *pSet = set;
+    if (pSet->setSize == 0) {
+        return false;
+    }
+    size_t contain_id = pSet->hash(item) % pSet->setSize;
+    if (contain_id >= pSet->setSize) {
+        return false;
+    }
+    int i;
+    for (i = contain_id; i < pSet->setSize; i++) {
+        if (pSet->conditions[i] == 1) {
+            if (pSet->equals(pSet->items[i], item) == true) {
+                return true;
+            }
+        }
+    }
+    for (i = 0; i < contain_id; i++) {
+        if (pSet->conditions[i] == 1) {
+            if (pSet->equals(pSet->items[i], item) == true) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+///*Добавить новый элемент.
+///*В случае успеха, функция возвращает true,
+///*если такой элемент уже существует -- false.
+bool set_insert(void *set, const void *item) {
+    if (set == NULL || item == NULL) {
+        return false;
+    }
+    SET *pSet = set;
+    if (pSet->setSize == 0) {
+        set_resize(set, 2);
+    }
+    size_t insert_id = find_place(pSet, item);
+    if (insert_id == set_stop(pSet)) {
+        set = set_resize(set, pSet->setSize * 2);
+        return set_insert(pSet, item);
+    }
+    if (insert_id == INVALID) {
+        return false;
+    }
+    if (pSet->conditions[insert_id] == 0) {
+        pSet->items[insert_id] = set_item_create(pSet->itemSize);
+        if (pSet->items[insert_id] != NULL) {
+            memcpy(pSet->items[insert_id], item, pSet->itemSize);
+        } else {
+            return false;
+        }
+        pSet->conditions[insert_id] = 1;
+        return true;
+    }
+}
+
+///*Найти элемент и удалить из множества.
+///*Если указана функция destroy, то вызвать её для удаляемого элемента setItem.///
+void set_remove(void *set, const void *item, void (*destroy)(void *)) {
+    if (set == NULL || item == NULL) {
+        return;
+    }
+    SET *pSet = set;
+    if (pSet->setSize == 0) {
+        return;
+    }
+    size_t remove_id = pSet->hash(item) % pSet->setSize;
+    for (int i = 0; i < pSet->setSize - remove_id; i++) {
+        if (pSet->conditions[remove_id + i] == 1) {
+            if (pSet->equals(pSet->items[remove_id + i], item)) {
+                if (destroy) {
+                    destroy(pSet->items[remove_id + i]);
+                }
+                free(pSet->items[remove_id + i]);
+                pSet->conditions[remove_id + i] = 0;
+                if (set_count(pSet) == 0) {
+                    set = set_resize(pSet, 0);
+                    return;
+                }
+                if (set_count(pSet) < pSet->setSize / 2) {
+                    set = set_resize(pSet, pSet->setSize / 2);
+                    return;
+                }
+            }
+        } else continue;
+    }
+    for (int i = 0; i < remove_id; i++) {
+        if (pSet->conditions[i] == 1) {
+            if (pSet->equals(pSet->items[i], item)) {
+                if (destroy) {
+                    destroy(pSet->items[i]);
+                }
+                free(pSet->items[i]);
+                pSet->conditions[i] = 0;
+                if (set_count(pSet) == 0) {
+                    set = set_resize(pSet, 0);
+                    return;
+                }
+                if (set_count(pSet) < pSet->setSize / 2) {
+                    set = set_resize(pSet, pSet->setSize / 2);
+                    return;
+                }
+            }
+        } else continue;
+    }
+
+    if (set_count(pSet) < pSet->setSize / 2 && set_count(pSet) != 0) {
+        set = set_resize(pSet, pSet->setSize / 2);
+    }
+}
+
+///*Идентификатор для первого элемента множества.
+///*Идентификатор может стать невалидным при модификации множества.*///
+size_t set_first(const void *set) {
+    if (set == NULL) {
+        return set_stop(set);
+    }
+    SET const *pSet = set;
+    size_t item_id;
+    for (item_id = 0; item_id < pSet->setSize; item_id++) {
+        if (pSet->conditions[item_id] == 1) {
+            return item_id;
+        } else {
+            continue;
+        }
+    }
+    return set_stop(pSet);
+}
+
+///*Идентификатор для последнего элемента множества.
+///*Идентификатор может стать невалидным при модификации множества.*///
+size_t set_last(const void *set) {
+    if (set == NULL) {
+        return set_stop(set);
+    }
+    SET const *pSet = set;
+    if (pSet->setSize == 0) {
+        return set_stop(pSet);
+    }
+    size_t item_id;
+    for (item_id = pSet->setSize - 1; item_id > 0; item_id--) {
+        if (pSet->conditions[item_id] == 1) {
+            return item_id;
+        } else {
+            continue;
+        }
+    }
+    return set_stop(pSet);
+}
+
+///*По идентификатору текущего элемента получить
+///*идентификатор следующего элемента множества.*///
+size_t set_next(const void *set, size_t item_id) {
+    if (set == NULL) {
+        return set_stop(set);
+    }
+    SET const *pSet = set;
+    if (pSet->setSize == 0) {
+        return set_stop(pSet);
+    }
+    size_t current_id = item_id % pSet->setSize;
+    if (current_id == pSet->setSize - 1) { //No place after
+        return set_stop(pSet);
+    }
+    for (int i = 1; i < pSet->setSize - current_id; i++) {
+        if (pSet->conditions[item_id + i] == 1) {
+            return current_id + i;
+        } else continue;
+    }
+    return set_stop(pSet);
+}
+
+///*По идентификатору текущего элемента получить
+///*идентификатор предыдущего элемента множества.*///
+size_t set_prev(const void *set, size_t item_id) {
+    if (set == NULL) {
+        return set_stop(set);
+    }
+    SET const *pSet = set;
+    if (pSet->setSize == 0) {
+        return set_stop(pSet);
+    }
+    size_t current_id = item_id % pSet->setSize;
+    if (current_id == 0) { //No place before
+        return set_stop(pSet);
+    }
+    for (int i = 0; i < current_id; i++) {
+        if (pSet->conditions[current_id - i] == 1) {
+            return current_id - i;
+        } else continue;
+    }
+    return set_stop(pSet);
+}
+
+///*Идентификатор, получаемый при попытке
+///*обратиться к элементу за пределами множества.*///
+size_t set_stop(const void *set) {
+    return INVALID - 1;
+}
+
+///*Получить указатель на элемент по его идентификатору.*///
+const void *set_current(const void *set, size_t item_id) {
+    SET const *pSet = set;
+    if (pSet == NULL || item_id >= pSet->setSize || pSet->setSize == 0 || pSet->conditions[item_id] == 0) {
+        return NULL;
+    }
+    size_t current_id = item_id % pSet->setSize;
+    return (pSet->items[current_id]);
+}
+
+///*Удаление элемента множества по его идентификатору.
+///*Если указана функция destroy, то вызвать её для удаляемого элемента множества.
+///*После удаления элемента,
+///*идентификаторы любых элементов из этого множества могут стать невалидным.///
+void set_erase(void *set, size_t item_id, void (*destroy)(void *)) {
+    if (set == NULL) {
+        return;
+    }
+    SET const *pSet = set;
+    if (pSet->setSize == 0) {
+        return;
+    }
+    size_t erase_id = item_id % pSet->setSize;
+    if (erase_id > pSet->setSize - 1) {
+        return;
+    }
+    if (pSet->conditions[erase_id] == 1) {
+        if (destroy != NULL) {
+            destroy(pSet->items[erase_id]);
+        }
+        free(pSet->items[erase_id]);
+        pSet->conditions[erase_id] = 0;
+    }
+}
\ No newline at end of file
Index: set.h
===================================================================
diff --git a/set.h b/set.h
new file mode 100644
--- /dev/null	
+++ b/set.h	
@@ -0,0 +1,24 @@
+#ifndef SET_SET_H
+#define SET_SET_H
+#include <stdbool.h> // bool
+#include <stddef.h>  // size_t
+
+static const size_t INVALID = ~((size_t)0);
+
+void* set_create(size_t itemSize, size_t hash(const void*), bool (*equals)(const void*, const void*));
+void set_destroy(void* set, void (*destroy)(void*));
+void* set_init(void* set, size_t itemSize, size_t hash(const void*), bool (*equals)(const void*, const void*),
+               void (*destroy)(void*));
+void set_clear(void* set, void (*destroy)(void*));
+size_t set_count(const void* set);
+bool set_contains(const void* set, const void* item);
+bool set_insert(void* set, const void* item);
+void set_remove(void* set, const void* item, void (*destroy)(void*));
+size_t set_first(const void* set);
+size_t set_last(const void* set);
+size_t set_next(const void* set, size_t item_id);
+size_t set_prev(const void* set, size_t item_id);
+size_t set_stop(const void* set);
+const void* set_current(const void* set, size_t item_id);
+void set_erase(void* set, size_t erase_id, void (*destroy)(void*));
+#endif //SET_SET_H
Index: ../set/.idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"CMakeRunConfigurationManager\" shouldGenerate=\"true\" shouldDeleteObsolete=\"true\">\r\n    <generated>\r\n      <config projectName=\"list\" targetName=\"list\" />\r\n    </generated>\r\n  </component>\r\n  <component name=\"CMakeSettings\">\r\n    <configurations>\r\n      <configuration PROFILE_NAME=\"Debug\" CONFIG_NAME=\"Debug\" ENABLED=\"true\" />\r\n    </configurations>\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"808d62af-7c91-4acf-93ca-453d1dae730f\" name=\"Default Changelist\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/CMakeLists.txt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/CMakeLists.txt\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/set.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/set.c\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ClangdSettings\">\r\n    <option name=\"formatViaClangd\" value=\"false\" />\r\n  </component>\r\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\r\n  </component>\r\n  <component name=\"GitSEFilterConfiguration\">\r\n    <file-type-list>\r\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\r\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\r\n      <filtered-out-file-type name=\"TAG\" />\r\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\r\n    </file-type-list>\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1pR9mph75lfrBK1ERnevIxgFwFO\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"cf.first.check.clang-format\" value=\"false\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../../list/CMakeLists.txt\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"CPPToolchains\" />\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration default=\"true\" type=\"CLionExternalRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\">\r\n      <method v=\"2\">\r\n        <option name=\"CLION.EXTERNAL.BUILD\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"list\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"list\" TARGET_NAME=\"list\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"list\" RUN_TARGET_NAME=\"list\">\r\n      <method v=\"2\">\r\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"GradleAppRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" PASS_PARENT_ENVS_2=\"true\">\r\n      <method v=\"2\">\r\n        <option name=\"com.jetbrains.cidr.cpp.gradle.execution.GradleNativeBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"808d62af-7c91-4acf-93ca-453d1dae730f\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1615135200233</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1615135200233</updated>\r\n      <workItem from=\"1615135209008\" duration=\"1276000\" />\r\n      <workItem from=\"1615217673761\" duration=\"3410000\" />\r\n      <workItem from=\"1615223925193\" duration=\"2186000\" />\r\n      <workItem from=\"1615307430347\" duration=\"3551000\" />\r\n      <workItem from=\"1615363982716\" duration=\"4668000\" />\r\n      <workItem from=\"1615514361436\" duration=\"3179000\" />\r\n      <workItem from=\"1615609180991\" duration=\"15600000\" />\r\n      <workItem from=\"1615718810581\" duration=\"4038000\" />\r\n      <workItem from=\"1615803278013\" duration=\"1312000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Гит хуета, сломалось все 10 раз.\">\r\n      <created>1615135406633</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615135406633</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Failure on set_destroy.\">\r\n      <created>1615136239673</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615136239674</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Need to realize create throw init.\">\r\n      <created>1615221037331</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615221037331</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Need to realize create throw init.\">\r\n      <created>1615309611196</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615309611196</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Init works throw calling create.\">\r\n      <created>1615309944178</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615309944178</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"Need to write tests.\">\r\n      <created>1615387699022</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615387699023</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"Tests added, works properly.\">\r\n      <created>1615517560913</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615517560914</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Memory leak 24 bytes detected.\">\r\n      <created>1615696719898</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615696719899</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Memory leak fixed.\">\r\n      <created>1615699162870</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615699162870</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"...\">\r\n      <created>1615721348995</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1615721348995</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"11\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Гит хуета, сломалось все 10 раз.\" />\r\n    <MESSAGE value=\"Failure on set_destroy.\" />\r\n    <MESSAGE value=\"Need to realize create throw init.\" />\r\n    <MESSAGE value=\"Init works throw calling create.\" />\r\n    <MESSAGE value=\"Need to write tests.\" />\r\n    <MESSAGE value=\"Tests added, works properly.\" />\r\n    <MESSAGE value=\"Memory leak 24 bytes detected.\" />\r\n    <MESSAGE value=\"Memory leak fixed.\" />\r\n    <MESSAGE value=\"...\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"...\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <watches-manager>\r\n      <configuration name=\"CMakeRunConfiguration\">\r\n        <watch expression=\"pSet-&gt;items-&gt;*items\" />\r\n      </configuration>\r\n    </watches-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../set/.idea/workspace.xml b/../set/.idea/workspace.xml
--- a/../set/.idea/workspace.xml	
+++ b/../set/.idea/workspace.xml	
@@ -1,9 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CMakeRunConfigurationManager" shouldGenerate="true" shouldDeleteObsolete="true">
-    <generated>
-      <config projectName="list" targetName="list" />
-    </generated>
+    <generated />
   </component>
   <component name="CMakeSettings">
     <configurations>
@@ -11,10 +9,25 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="808d62af-7c91-4acf-93ca-453d1dae730f" name="Default Changelist" comment="">
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/CMakeLists.txt" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/set.c" beforeDir="false" afterPath="$PROJECT_DIR$/set.c" afterDir="false" />
+    <list default="true" id="a462112a-5d27-497f-bbcf-55e1b86dd200" name="Default Changelist" comment="">
+      <change afterPath="$PROJECT_DIR$/../lab_set/CMakeLists.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/../lab_set/main.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/../lab_set/set.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/../lab_set/set.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/../lab_chat_bot/.idea/lab_chat_bot.iml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../lab_chat_bot/.idea/misc.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/../lab_chat_bot/.idea/workspace.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/.name" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/modules.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/set.iml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_15_03_2021_17_50__Default_Changelist_.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/vcs.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/CMakeLists.txt" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/main.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/set.c" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/set.h" beforeDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -24,8 +37,12 @@
   <component name="ClangdSettings">
     <option name="formatViaClangd" value="false" />
   </component>
-  <component name="ExecutionTargetManager" SELECTED_TARGET="CMakeBuildProfile:Debug" />
   <component name="Git.Settings">
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$/.." value="lab_set" />
+      </map>
+    </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
   </component>
   <component name="GitSEFilterConfiguration">
@@ -47,18 +64,13 @@
     <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
     <property name="WebServerToolWindowFactoryState" value="false" />
     <property name="cf.first.check.clang-format" value="false" />
-    <property name="last_opened_file_path" value="$PROJECT_DIR$/../../list/CMakeLists.txt" />
+    <property name="last_opened_file_path" value="$PROJECT_DIR$/set.c" />
     <property name="settings.editor.selected.configurable" value="CPPToolchains" />
   </component>
   <component name="RunManager">
     <configuration default="true" type="CLionExternalRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true">
       <method v="2">
         <option name="CLION.EXTERNAL.BUILD" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="list" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="list" TARGET_NAME="list" CONFIG_NAME="Debug" RUN_TARGET_PROJECT_NAME="list" RUN_TARGET_NAME="list">
-      <method v="2">
-        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
       </method>
     </configuration>
     <configuration default="true" type="GradleAppRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true">
Index: CMakeLists.txt
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
--- /dev/null	
+++ b/CMakeLists.txt	
@@ -0,0 +1,6 @@
+cmake_minimum_required(VERSION 3.17)
+project(lab_set C)
+
+set(CMAKE_C_STANDARD 11)
+
+add_executable(lab_set main.c set.c set.h)
\ No newline at end of file
Index: main.c
===================================================================
diff --git a/main.c b/main.c
new file mode 100644
--- /dev/null	
+++ b/main.c	
@@ -0,0 +1,157 @@
+#define _CRTDBG_MAP_ALLOC
+#include <string.h>
+#include <assert.h>
+#include "set.h"
+#include <crtdbg.h>
+
+typedef struct {
+    char name[10];
+} KeyValue;
+
+static size_t hash(const void* ptr) {
+    const int p = 31;
+    const int m = 1e9 + 9;
+    size_t hash_value = 0;
+    size_t p_pow = 1;
+
+    const KeyValue* keyValue = (const KeyValue*)ptr;
+
+    for (size_t i = 0; i < 10; ++i) {
+        const char c = keyValue->name[i];
+        hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;
+        p_pow = (p_pow * p) % m;
+    }
+
+    return hash_value;
+}
+
+
+static bool equals(const void* lhsp, const void* rhsp) {
+    const KeyValue* lhs = (const KeyValue*)lhsp;
+    const KeyValue* rhs = (const KeyValue*)rhsp;
+
+    return 0 == strcmp(lhs->name, rhs->name);
+}
+
+//static size_t hash_1(const void *ptr) {
+//    return (size_t) &ptr;
+//}
+
+//static bool equals_1(const void* first, const void* second) {
+//    int a = (int) &first;
+//    int b = (int) &second;
+//    return a == b;
+//}
+
+int main() {
+    {//Создаем множество с элементами типа KeyValue;
+        void *set = set_create(1, hash, equals);
+        //Создаем ключ-значение для множества
+        const KeyValue keyValue = {"Key-value"};
+        const KeyValue keyValue1 = {"Key-valu1"};
+        const KeyValue keyValue2 = {"Key-valu2"};
+        const KeyValue keyValue3 = {"Key-valu3"};
+        const KeyValue keyValue4 = {"Key-valu4"};
+        const KeyValue keyValue5 = {"Key-valu5"};
+        set = set_init(set, sizeof(KeyValue), hash, equals, NULL);
+        assert(set_init(NULL, 8, hash, equals, NULL) == NULL);
+        set_erase(set, (size_t) &keyValue, NULL);
+        assert(set_contains(set, NULL) == false);
+        assert(set_next(set, (size_t) &keyValue) == set_stop(set));
+        assert(set_prev(set, (size_t) &keyValue) == set_stop(set));
+        assert(set_last(set) == set_stop(set));
+        assert(set_first(set) == set_stop(set));
+        assert(set_insert(set, NULL) == false);
+        assert(set_insert(NULL, &keyValue) == false);
+        assert(0 == set_count(set));
+        assert(set_stop(set) == set_first(set));
+        assert(set_stop(set) == set_last(set));
+        assert(set_next(NULL, 2) == set_stop(NULL));
+        assert(set_next(set, set_first(set)) == set_stop(set));
+        assert(set_next(set, set_last(set)) == set_stop(set));
+        assert(set_prev(set, set_first(set)) == set_stop(set));
+        assert(set_prev(set, set_last(set)) == set_stop(set));
+        assert(set_contains(set, &keyValue) == false);
+        assert(set_stop(set) + 1 == set_count(NULL));
+
+        assert(set_insert(set, &keyValue));
+        assert(set_count(set) == 1);
+        assert(set_first(set) == set_last(set));
+
+
+        assert(set_insert(set, &keyValue1));
+        assert(set_count(set) == 2);
+        assert(set_insert(set, &keyValue2));
+        assert(set_count(set) == 3);
+        assert(set_insert(set, &keyValue3));
+        assert(set_count(set) == 4);
+        assert(set_insert(set, &keyValue4));
+        assert(set_count(set) == 5);
+        assert(set_insert(set, &keyValue5));
+        assert(set_count(set) == 6);
+        set_remove(set, &keyValue, NULL);
+        assert(set_count(set) == 5);
+        set_clear(set, NULL);
+        size_t y = set_stop(set);
+        size_t x = set_first(set);
+        assert(set_stop(set) == set_first(set));
+        assert(set_insert(set, NULL) == false);
+
+
+        //Добавляем ключ-значение
+        const bool isCreated = (KeyValue *) set_insert(set, &keyValue);
+        assert(true == isCreated);
+
+        assert(true == set_contains(set, &keyValue));
+        const KeyValue *item = (const KeyValue *) set_current(set, set_first(set));
+
+        assert(0 == strcmp(item->name, keyValue.name));
+
+        assert(set_last(set) == set_first(set));
+
+        assert(set_next(set, set_first(set)) == set_stop(set));
+
+        set_erase(set, hash(&keyValue), NULL);
+        assert(set_contains(set, &keyValue) == false);
+        assert(set_count(set) == 0);
+        assert(set_count(NULL) == -1);
+
+        set_destroy(set, NULL);
+    }
+    {
+        void *Set = set_create(sizeof(KeyValue), hash, equals);
+        const KeyValue key_value = {"Key-value"};
+        int count = 0;
+        bool insert_flag;
+        for (size_t i = 0; i < 100; i++) {
+            insert_flag = set_insert(Set, &key_value);
+            if (insert_flag) {
+                count++;
+            }
+            assert(set_count(Set) == count);
+        }
+        assert(set_count(Set) == count);
+        for (size_t i = 0; i < 100; i++) {
+            set_remove(Set, &key_value, NULL);
+            if (set_count(Set) == count - 1) {
+                count--;
+            }
+            assert(set_count(Set) == count);
+        }
+
+        set_destroy(Set, NULL);
+    }
+    // Send all reports to STDOUT
+    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
+    _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
+    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
+    _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
+    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
+    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);
+
+    _CrtDumpMemoryLeaks();
+
+
+    return 0;
+
+}
\ No newline at end of file
